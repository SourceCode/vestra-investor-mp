Unified Real Estate Investment Platform – Product Requirements Document (PRD)

1. Overview and Objectives

The Unified Real Estate Investment Platform is a multi-tenant, cloud-based system that streamlines the end-to-end lifecycle of real estate investment deals. It will serve a broad spectrum of users – investors, wholesalers (and their agents), lenders, title companies, insurance providers, and technology partners – within a single integrated platform. The goal is to connect all parties in the real estate investment ecosystem, enabling seamless deal flow, integrated services, and data-driven decision making.

Key Objectives:
	•	Multi-Tenant Marketplace: Allow each real estate wholesaler or brand to operate their own marketplace within a shared platform, with strict tenant isolation and branding flexibility ￼. Wholesalers can publish deals, manage investors, and optionally share deals across the network (“deal share”) under controlled conditions ￼ ￼.
	•	Modern User Experience: Provide a modern, responsive web application (built with Next.js + React, TypeScript, Vite) and micro-frontend architecture so feature modules can be developed and deployed independently. Ensure a cohesive UI/UX across modules with Material UI and Tailwind CSS for styling consistency.
	•	Robust Deal Lifecycle Management: Support the full deal lifecycle from onboarding investors, listing properties, bidding/offers, through contracting, closing, and post-sale services. Integrate messaging, notifications, payments for down payments, contract generation, and compliance checks into the workflow.
	•	Integrated Services & Partnerships: Embed essential services like title, lending, insurance, contractors, and loyalty rewards directly into the platform experience ￼ ￼. Provide open integration APIs (REST and tRPC) so that external service providers and CRM systems can connect via adapter modules.
	•	Data-Driven Insights and Automation: Include an analytics dashboard for stakeholders to monitor performance (deal conversion rates, investor engagement, etc.) ￼. Provide automated notifications and an AI-driven recommendation engine to personalize deal alerts to investors’ preferences (e.g. filter out deals with pools for buy-and-hold landlords as described in persona scenarios ￼). Over time, leverage AI to assist agents (e.g. automatically triage leads, suggest follow-ups).
	•	Scalability and Security: Architect the platform to scale to many tenants and users with containerized microservices and event-driven communication. Enforce strict security and compliance, including a configurable RBAC/ABAC permission model to ensure users only access data within their organization’s scope. Protect sensitive data and use secure development practices (code linting, testing, secret management, CI/CD).

This PRD prioritizes the core needs of investors, wholesalers, and agents in the initial phases, as they are the primary users driving marketplace activity. Lenders, title/insurance providers, and tech partners are incorporated in later phases via integrations once the core platform is in place.

2. User Personas and Needs

2.1 Investor (Buyer) Persona

Profile: Individual or institutional buyers seeking investment properties. Often juggling multiple sources to find deals, they desire convenience, good deal flow, and value-added services (financing, renovation discounts, etc.).

Key Needs & Pain Points:
	•	Deal Discovery: Easily browse and search for properties (filter by area, price, etc.) with enough detail to evaluate the opportunity ￼. Investors don’t want to waste time on deals they can’t see or don’t fit their criteria.
	•	Access & Onboarding: Quick onboarding to view deals. In current systems, investors often must attend a call or meeting before seeing full property details. The platform should streamline this with a self-service onboarding link that handles necessary disclosures and agent assignment, then “unlocks” full deal access ￼.
	•	Personalized Alerts: Receive notifications about new deals that match their preferences. Ability to fine-tune these alerts by providing feedback (“no pool”, “looking for duplexes”, etc.), which the system remembers ￼.
	•	Bidding & Purchase: Participate in bidding or offer submission digitally. Investors want transparency in the offer process and the ability to secure a deal quickly. For competitive situations, the platform should support an auction-like bidding process with real-time updates.
	•	Down Payment & Contracting: If an investor’s offer is accepted or they win a bid, they need to secure the deal by placing a deposit (earnest money/down payment) easily through the platform ￼. They also want a swift contracting process – e.g. auto-generated contracts and e-signature.
	•	Integrated Financing: Optionally, investors can pre-qualify for financing within the platform. For example, an AI chatbot can collect financial info to get a loan pre-approval, so that each deal listing shows the investor their estimated loan and monthly payment ￼. This helps investors know what they can afford and speeds up closing ￼.
	•	Value-Added Services: Access to partnership perks such as renovation discounts (e.g. Home Depot), property management offers, or resale listing discounts. In the future vision, an investor could see tools like a 3D AR floor plan that generates a Home Depot cart with discounted materials to estimate rehab costs ￼. These incentives (loyalty rewards, service bundles) save them money, effectively enabling them to pay more for properties and still profit ￼.
	•	Post-Purchase Support: Tools to assist after purchase – e.g. landlord portfolio management or an easy connection to list the property if flipping ￼ – ideally integrated, especially if there are promotions for using them immediately after closing (as noted in persona story about deeper discounts when services are bundled right after purchase ￼).

Priority: Investors are high priority. Without engaged investors, deals won’t close. MVP must address their core needs: deal discovery, onboarding, notifications, bidding, and easy closing. Advanced features like embedded financing and loyalty rewards are secondary (introduced in later phases) but should be in the roadmap.

2.2 Wholesaler Persona (Marketplace Operator)

Profile: A wholesale real estate company or an independent wholesaler who sources off-market deals and assigns them to investors. Often employs agents (Acquisition agents who find deals, and Disposition agents who sell deals to investors).

Key Needs & Pain Points:
	•	Marketplace Management: Ability to create and manage their own branded marketplace for deals ￼. This includes posting new deals (property info, photos, ARV, etc.), managing deal status (available, under contract, sold), and controlling which investors see which deals.
	•	Investor Network Management: Tools to manage their list of investor buyers. They want to onboard new investors easily – e.g. by sending an invite link or posting a teaser on social media that leads prospects into registration ￼. The platform should collect necessary info (accreditation status, purchase criteria, required disclosures) and then let the wholesaler approve/unlock the investor to see deals ￼. This removes manual follow-ups and scales their reach.
	•	Deal Distribution & Sharing: Wholesalers want to maximize deal exposure but also protect relationships. The platform should allow controlled deal sharing. For example, if they have excess inventory or a deal outside their usual buy-box, they can opt to share it with other wholesalers’ investors in the network. Conversely, if their investors are not biting, an option to share deals to a broader pool can help sell faster. The platform will ensure no cross-tenant data leaks – an investor sees at most one wholesaler’s version of a deal ￼ ￼. Any cross-tenant deal sharing must be deliberate and rules-based (with audit logs).
	•	Communication & Engagement: Integrated messaging and notification tools to communicate with investors. For example, when a new deal is posted, automatic notifications go out. If an investor expresses interest (e.g. “likes” a deal or clicks interested), the assigned agent gets notified to follow up ￼. This keeps investors warm and speeds up conversions.
	•	Analytics & Performance: A dashboard of analytics showing their business metrics: number of active investors, email open rates, bids per deal, days on market for deals, assignment fees earned, etc. ￼. This data helps them optimize operations and prove the value of the platform (e.g. to adjust marketing or identify top buyers).
	•	CRM Integration: Many wholesalers use external CRMs (Salesforce, HubSpot, etc.) to track leads and transactions. The platform should sync key data to/from CRMs so that adopting the new platform doesn’t require abandoning their existing systems. A “CRM sync” feature (with an easy data ingestion button) is considered a should-have shortly after MVP ￼. It should pull in leads or contacts from CRM to the platform and push back deal activity to the CRM, through a robust adapter mechanism.
	•	Workflow & Compliance: Support their operational workflows:
	•	Contract Generation: Automatically generate assignment contracts or purchase agreements with correct terms when an investor commits, saving time on paperwork (a should-have feature ￼).
	•	Down Payments Handling: Accept earnest money/down payments through the platform to discourage walkaways ￼. The wholesaler should be notified when a deposit is made and see it tied to the deal.
	•	Compliance: Include features to handle state/federal compliance (e.g. specific disclaimers, double closing laws, licensing). Also possibly track that agents and users have completed any required training (in the persona story, a compliance training was mentioned as part of their routine ￼).
	•	Multi-Market Support: If a wholesaler operates in multiple regions or states, allow configuration of market-specific settings (contract templates, required disclosures, etc.) under their account settings (part of Account Management / Market Configuration ￼).
	•	Revenue and Loyalty Programs: Wholesalers can benefit from loyalty programs and referrals. The platform should allow them to earn credits or referral fees when their investors use ancillary services. For example, if an investor financed a deal or bought insurance via the platform, the wholesaler might get a platform credit or commission ￼. These can incentivize wholesalers to promote the platform’s integrated services. Additionally, a rewards program can encourage investors to remain loyal to a wholesaler’s marketplace (e.g. volume discounts, points for each purchase redeemable for perks).

Priority: Wholesalers (particularly their owners/admins) are top priority alongside investors for initial launch. The platform’s value proposition to wholesalers is critical: it should simplify their operations and broaden their investor reach (thereby increasing deal volume). Core features like deal management, investor onboarding, and basic analytics must be in the MVP ￼. Integrations (CRM sync, advanced analytics) and loyalty programs come slightly later but should be designed early to fit into the architecture.

2.3 Agent Persona (Disposition/Acquisition Agents)

Profile: Agents working for wholesalers – Disposition Agents who handle selling deals to investors, and Acquisition Agents who find and bring in deals. They are the daily users managing inventory and relationships.

Key Needs & Pain Points:
	•	Ease of Use & Training: Agents need a user-friendly interface to manage deals and communicate with many investors. They benefit from guided workflows since turnover can be high and not all agents are tech-savvy. Regular updates/training (even gamified, as envisioned for future with quick quizzes ￼) can help them stay compliant and effective, but the platform itself should be intuitive.
	•	Deal Entry & Management: Acquisition agents require a quick way to input new deals (property info, comps, estimates). Disposition agents need to update status (price adjustments, under contract, etc.) and possibly share deals with specific investors or groups. They want to avoid duplicate data entry (e.g. if they already put info in an internal system or CRM, it should sync).
	•	Investor Engagement Tools: Dispo agents rely on strong relationships. The platform should aid them with automated follow-ups and reminders. For example, if an investor views a deal but doesn’t act, the agent might get a task reminder to call them. In the future, an AI assistant could help monitor the agent’s communications and pipeline (the persona narrative imagines an AI that scans the agent’s inbox and deal system to auto-schedule follow-ups and fill their calendar ￼ – this is a long-term feature indicating where we’re headed).
	•	Bidding & Offer Management: When multiple investors are interested, the platform handles the heavy lifting: showing the agent the live bids, enabling them to approve the winning bid (or set auto-rules like first bid above a threshold wins). Agents need transparency and control in this process, along with the ability to quickly send a contract to the winner.
	•	Collaboration & Deal Sharing: Agents should be able to tap into the broader network when needed. For example, a Dispo agent with a surplus of deals can mark some as “network share” so other teams’ investors can see them, earning the agent a disposition fee if another team’s investor buys ￼. This requires clear rules to avoid conflicts (the platform can enforce that an investor sees only one agent’s contact per deal to prevent confusion ￼).
	•	Access to Investor Insights: When dealing with an investor, agents want context – e.g., see that investor’s past purchases, their stated criteria, whether they are pre-qualified for financing (so the agent knows they are serious) ￼. The platform should provide a quick investor profile and even a “credibility score” (for example, highlight if they have their proof of funds in file or have defaulted on any past contract).
	•	Mobile Accessibility: Agents are often in the field (at properties or meeting investors). A responsive mobile interface or dedicated app is crucial so they can respond to leads, upload property photos, and manage deals on the go.

Priority: Agents are high priority users in the MVP since they are the ones who will populate and operate the system day-to-day. The MVP should include the core tools for agents: deal input, investor list management, messaging, and the ability to handle offers. Advanced AI assistance and deep network collaboration features can be phased in later, but basic collaboration (like internal deal sharing within an organization) should be present early. Ensuring the system actually saves agents time (not adding tedious steps) is key for adoption.

2.4 Lender, Title, Insurance Partner Personas

Profile: Representatives of service providers (hard money lenders, title companies, insurance agencies) who integrate with the platform to offer their services at relevant points in the deal process.

Needs & Use Cases:
	•	Integration Points: These users might not log into the UI frequently; instead the platform will surface their services to investors/agents as needed. For instance, a title company user may receive an order or notification when a deal goes under contract in the platform, and they need to update status (clear title, schedule closing) which should reflect back to the deal timeline. Lenders might want to provide loan offers or see when an investor requests financing.
	•	APIs and Portal: The platform should provide secure APIs or a lightweight portal for these partners. For MVP, basic integration could be via email notifications or webhooks (e.g. “New deal under contract, please initiate title work”). Eventually, full integration via API (or tRPC client) will allow direct updating of status and retrieval of documents.
	•	Service Configuration: Each tenant (wholesaler org) might have preferred partners (e.g. a preferred title company). The platform should allow configuration of which partner is associated with a tenant’s deals, so that, for example, when a contract is created it automatically notifies the correct title company.
	•	Value Proposition: These partners get business through the platform (e.g., more policies, loans, etc.), so they will comply with certain data exchange formats. They need assurance that sensitive data is handled securely and that they only have access to deals relevant to them. They also might want analytics (how many deals they got from the platform, conversion rates).
	•	Persona priority: These are secondary personas. They are integrated in phases once the core marketplace is functional. Early on, their integration might be mocked or manual. As the platform matures, building robust partner integrations and possibly a partner management module (for onboarding new service partners) will be important for scaling the “ecosystem”.

2.5 Technology Service Partner Persona

Profile: Third-party technology providers that could extend the platform’s capabilities – e.g. a company providing a specialized analytics tool, or a service like an AI valuation model, etc. They might want to plug into the platform as well.

Needs & Use Cases:
	•	API Access: These partners primarily need well-documented APIs (REST/tRPC) to integrate their technology or pull data. For example, a proptech service might integrate to automatically valuate properties or provide a renovation estimate within the platform.
	•	Micro-Frontend Integration: In some cases, the platform could allow micro-frontend contributions where a partner’s widget can be embedded in the UI for a tenant (with permission). For instance, a specialized mortgage calculator UI from a partner could be plugged into the deal page.
	•	Sandbox and Developer Support: The platform should eventually offer sandbox environments, API keys, and documentation for tech partners. This is not an MVP need but will be on the roadmap to encourage an ecosystem of plugins.

Persona priority: Secondary/tertiary – to be addressed after core platform and primary user functionality are stable. However, designing the system with open APIs from the start will make later integration easier.

3. Core Functional Areas & Features

The platform encompasses several functional areas, each with specific features. Below, we detail each area, with feature descriptions, the primary personas served, and any key dependencies. We also indicate priority: P1 = required for MVP, P2 = next phase (should-have), P3 = later optimization or could-have.

3.1 Onboarding & User Management
	•	Self-Service Registration (Investors) – P1: Investors can sign up via a branded registration page for a wholesaler’s marketplace. The flow includes identity verification and required disclosures/compliance acknowledgments. For example, a new investor clicking a shared link goes through account creation, agrees to terms, and is then guided to schedule a call or an e-meet with an agent if required ￼. Dependency: Need identity/auth service and a way to store investor profile info and compliance flags.
	•	Investor Qualification & Unlocking – P1: After registration, the investor might initially see limited deal info (e.g. property city/ZIP but not full address or price) until a wholesaler’s agent unlocks them. The agent can review the investor’s info (or have a quick intro call) and then mark them as approved, granting access to deals ￼. This ensures quality control and personal touch before full access. Dependency: Requires role-based access control and a flag on investor accounts for “approved” vs “prospect”.
	•	Organization (Tenant) Signup – P2: Ability for a new wholesaler organization to onboard onto the platform. This might be handled internally (our team creates the tenant), but eventually a self-service flow for a wholesaler to sign up, configure their brand settings (logo, company info, default terms), and invite their team (agents, admins) is needed. Dependency: Multi-tenant data model and admin interface.
	•	User Roles & Permissions – P1: Support multiple roles within an org: e.g. Org Owner/Account Owner (full access, billing management), Admin (manage users, deals), Disposition Agent (manage deals and investors), Acquisition Agent (input new deals, maybe limited investor access), Investor (view deals, submit offers), etc. Permissions are predefined for each role (and configurable by tenant admins in advanced scenarios). The system enforces that users can only see and act on data for their tenant (except explicitly shared data).
	•	Profile Management & Settings – P1: Each user (especially investors and agents) can manage their profile: update contact info, notification preferences (e.g. SMS or email alerts), and for investors, their investment criteria (to tailor deal feeds). Orgs can manage their company profile and preferences (like default down payment percentage required, or whether they auto-allow certain investors).

3.2 Deal Lifecycle Management

This is the core of the platform, covering from deal creation to closing.
	•	Deal Creation & Import – P1: Acquisition agents (or admins) can create a new deal entry. They input property details (address, photos, price, ARV, description, etc.), or import from a CSV/Excel or CRM if they have bulk deals (the “easy button” data ingestion for CRM is a target should-have ￼). Each deal is tagged to the creating tenant and initially in a draft status. Dependency: Property data model, media storage for photos.
	•	Deal Publishing – P1: Once ready, a deal can be published to the marketplace. Publishing makes it visible to that wholesaler’s approved investors via the investor portal (and triggers notifications). The publisher can choose to also share the deal with the broader network (if that feature is enabled and the deal meets certain criteria). Shared deals might appear in other tenants’ marketplaces labeled as “external” or under a network section. Business rules (like fee sharing or permission from admin) control this. Dependency: Multi-tenant share logic, possibly an internal “exchange” service.
	•	Marketplace Browsing (Investor UI) – P1: Investors have a Marketplace screen where they can browse available deals. They can search by various filters (location radius, price range, rental vs flip potential, etc.) and see results on a list or map view ￼. Each deal listing shows key info and a status (Available, Under Offer, etc.). If the investor has not been unlocked, sensitive info like exact address or maybe list price might be blurred with a prompt “Contact your agent to unlock full details”.
	•	Deal Detail View – P1: A detailed page for each property listing the full info: address, price, estimated ARV, rehab estimates (if provided), rent estimate, photos/gallery, documents (appraisal, inspection if any), and a contact/assigned agent info. Investors can indicate interest (which can simply notify the agent), or proceed to place an offer/bid.
	•	Bidding/Offer Process – P1: The platform supports two modes: direct buy (first come first serve with a fixed price and immediate contract) or bidding (an auction style or highest/best offers by a deadline). For MVP, we prioritize a simple offer system: an interested investor clicks “Submit Offer”, enters their offer amount (if not fixed price) and any conditions, and possibly pre-authorizes the down payment at this stage ￼. The offer is recorded. If multiple offers are allowed, the disposition agent can see all offers and choose to accept one.
	•	For auctions (P3, advanced bidding): The system can open a timed bidding window, display current highest bid to all participants, and automatically handle increments. In the persona example, investors showed up (virtually or physically) for a bidding window and had to pre-authorize a non-refundable deposit to join ￼, and the system facilitated a competitive bid that one wins by a small margin.
	•	Down Payment & Escrow – P2 (MVP for manual, P1 for tracking): When an offer is accepted, the investor must put down a non-refundable deposit (earnest money) to secure the deal. The platform should integrate with a payment processor (e.g. Stripe, ACH transfer) to collect this. At minimum, MVP can simply record that the investor promised to pay and an admin marks it received if done offline. But an integrated online payment is highly preferred to prevent any delay or uncertainty. The deposit status is visible on the deal, and only once received does the deal move to Under Contract.
	•	Contract Generation & E-Signature – P2: Upon accepting an offer, the platform generates the assignment contract or purchase agreement populated with deal details, buyer and seller info, price, and terms. This can be a PDF auto-generated from a template. Both parties (the investor/buyer and wholesaler/seller or their reps) can then electronically sign via an integrated e-signature service (DocuSign or similar). This feature significantly speeds up the transaction and is marked as a “should-have” after the initial must-haves ￼.
	•	Transaction Management (Closing) – P2: Once under contract, the deal goes into a closing phase. The platform should show a checklist/timeline (Title work, insurance binding, financing, etc.). Integrated title company and lender services come into play here. For MVP, the platform may simply provide contact info and status fields for these steps. Later phases will have APIs with title/lender so that, for example, the title company can update “title cleared on [date]” and upload the preliminary title report. A built-in transaction coordinator view (either for the wholesaler admin or provided by the title partner) can ensure all steps complete.
	•	Deal Closing & Archiving – P1: Mark a deal as Sold/Closed once the transaction is done. This triggers final notifications to relevant parties and archives the deal in the historical database. After closing, the investor might be prompted with post-sale resources (like “Check out our property management partners” or “Activate your Home Depot discount for your rehab”).
	•	Post-Deal Feedback & Loyalty – P3: After closing, the platform can solicit feedback (was the deal as expected, how was the process) and then reward loyalty. For example, award the investor points or credits for completing a purchase, and if they use integrated services (financing, etc.), possibly additional credits ￼. These points might be used for discounts on future deals or service fees. This area will support retention and cross-sell of services.

3.3 Messaging & Notifications
	•	In-App Messaging – P1: Basic capability for investors to send messages or questions to the agent/wholesaler within the platform (e.g. on a deal page, “Ask a question” chat). Agents should have a unified inbox to manage these conversations. This reduces reliance on external emails and keeps communications tied to the deal.
	•	Email/SMS Notifications – P1: The system should send out notifications for key events:
	•	New deal listed (to investors who match criteria or all investors of that tenant, depending on settings).
	•	Price reduction or status change on a deal.
	•	An investor’s offer accepted or outbid notifications.
	•	Messages waiting (if user is offline, email them that they have a message).
	•	System alerts like “Investor X has completed onboarding, please unlock them.”
These notifications should be configurable (users can opt in/out of certain types, and orgs can template them).
	•	Customized Deal Alerts – P2: Allow investors to save searches or preferences (e.g. “Show me all deals in ZIP 752XX under $200k”) and get alerts when matching deals hit the marketplace. Over time, incorporate an AI/ML layer to refine alerts based on what the investor views or ignores (as Larry’s persona described, the app learns from “not interested because…” feedback ￼).
	•	Push Notifications & Mobile – P3: If/when a mobile app or PWA is available, enable push notifications for real-time alerts on device.
	•	Inter-tenant Notifications for Shared Deals – P3: If using deal sharing, design notifications such that if Tenant A shares a deal to Tenant B’s investors, the appropriate parties are notified (e.g. Tenant A’s agent knows which external investors showed interest; Tenant B’s admin can see external deals being offered).
	•	Audit & Compliance in Communication – P2: Log all messages and notifications for compliance. Certain communication (like sending contract details) might require secure handling. Ensure the system can archive communications in case of disputes or audits.

3.4 Payments (Down Payments & Billing)
	•	Down Payment Processing – P2: As mentioned, integrate a payment gateway to handle earnest money deposits on deals. This could be via credit card (for smaller option fees) or ACH for larger amounts, possibly escrowed in a broker trust account. The platform needs to securely handle these transactions and mark them against the deal record. Dependency: third-party payment API, secure vaulting of payment info if needed.
	•	Marketplace Transaction Fees – P3: If the platform operator (our company) charges a marketplace fee or if there are revenue-sharing arrangements (like a fee on each deal or subscription fees for orgs), billing functionality will be needed. Possibly the billing API mentioned ￼. For MVP, assume revenue model is outside the system or simple (could track manually). In later phases, implement billing per tenant (e.g. monthly subscription or usage-based).
	•	Partner Services Payments – P3: If the platform facilitates payments for partner services (insurance premium payment, contractor deposit, etc.), integrate those payment flows as needed. Early on, might just link out to the service provider.

3.5 Contracting & Document Automation
	•	Dynamic Templates – P2: Provide templating for common documents: assignment contracts, purchase agreements, JV agreements, etc. Tenants can use a standard template or customize their own (for advanced orgs). The platform merges deal and party data into the template to produce ready-to-sign PDFs.
	•	Integrated E-Signature – P2: As noted, integrate a service like DocuSign, HelloSign, or use an open-source solution for collecting electronic signatures on documents right in the app. Status of signatures (who signed, who’s pending) should be visible.
	•	Automated Document Generation – P3: Beyond contracts, automate other docs: e.g. a deal brochure or pro forma that investors can download, or a scope of work document if rehab estimates are provided. This falls under document automation (listed as a “could-have” ￼).
	•	Document Storage & Access – P1: Even before full automation, the platform should store documents related to a deal: uploaded photos, PDFs (like appraisal, title commitment, etc.). A secure document repository per deal with appropriate access (investor might see some, internal users see more).
	•	Compliance Docs & Training – P3: Automate generation of any needed compliance documents, e.g. an affidavit or a disclosure form for certain states. Additionally, track agent training certifications (could generate certificates). This is an advanced need but should be noted for future (ensuring platform supports adding such features).

3.6 Compliance & Security Features
	•	Access Control & Data Isolation – P1: Strict multi-tenancy is a core requirement. Every request in the system must be scoped to the user’s organization context, ensuring no cross-tenant data leakage. For example, even if two wholesalers use the platform, one should never see another’s investors or deals (unless explicitly shared via the deal share feature). The product will enforce org ID filtering on all data queries and use a consistent tenancy framework across services.
	•	Permission Model (RBAC/ABAC) – P1: Implement robust role-based access control (RBAC) with support for attribute-based rules for finer control ￼ ￼. For instance, a disposition agent can only view deals assigned to them or in their market (an attribute constraint), not all deals in the org. Or an investor user can only make an offer if they have completed certain steps (attribute = “completed onboarding”). This will be built into the design of features from day one – every new feature must define what roles have access and any tenant/attribute constraints ￼.
	•	Audit Logs – P2: Keep an audit trail of critical actions: login attempts, data exports, deal status changes, etc., with timestamps and user IDs. This is important for security and compliance (and internal troubleshooting).
	•	Compliance Workflows – P2: Support compliance processes like KYC for investors (if required for large transactions), maintaining records of required licensure (e.g. agents’ real estate licenses on file and not expired), state-specific contract differences (e.g. some states require specific contract language). This likely requires configuration per tenant or per state. Our platform should allow flags or rules to be configured (e.g. “if deal is in State X, require attachment Y and restrict sale to certain buyer types”).
	•	Privacy and Data Protection: Ensure handling of personal data (PII) meets standards like GDPR/CCPA if applicable (especially if expanding beyond US). The system should not expose investor contact info openly to other investors, etc. Each tenant essentially has its own database schema view from the application perspective (even if physically shared DB, logically it’s siloed).
	•	Secrets and Config Management: (Dev/Tech detail but impacting product) – For any integrations, e.g. a particular tenant’s Salesforce API key, the platform will store these secrets securely (in encrypted form) and not expose them. This ensures each org’s integration credentials are safe. The product may provide an interface for org admins to enter their API keys for CRM etc., which then gets encrypted and used by backend.

3.7 Analytics & Insights
	•	Marketplace Analytics Dashboard – P2: Provide each wholesaler org a dashboard with key metrics: number of active investors, new signups, deal views, offers made, conversion rate (offers to closed deals), average days on market, revenue earned, etc. ￼. Visualize data with charts and allow filtering by date ranges, markets. This helps them manage their business and also demonstrates platform value (especially if we as platform provider also see aggregate stats).
	•	Investor Analytics for Agents – P3: Tools for an agent to see how their investors are interacting: e.g. which deals a specific investor viewed or ignored, the last time they logged in, their bidding history. This can help agents prioritize outreach (focus on engaged investors or re-engage inactive ones).
	•	Platform-level Analytics – P3: For the platform operator (internal use), an aggregate view across tenants: total deals across all, overall investor base growth, etc. Also a way to identify patterns (like which features drive more closes).
	•	Real-time Monitoring – P3: Some aspects (like a live view of an ongoing bidding war) might be nice for visualization, but primarily internal. Not MVP, but consider websockets or real-time feeds for critical data in the future (e.g., a live ticker of offers during an auction).
	•	Reporting & Exports – P2: Ability for users to export data (their deals list, investor list, etc.) as CSV or PDF reports. Also scheduled email reports (e.g. weekly summary of activity).
	•	AI-Driven Insights – P3: As data accumulates, provide AI-driven insights, e.g. “Investors who view property A also tend to view B” to recommend deals to investors, or “Optimal time to send deals is 9am Monday for your audience” to advise agents. This forward-looking feature aligns with making the platform a smart assistant, not just a data holder.

3.8 Partnerships, Loyalty & Rewards
	•	Partner Service Integration – P2: Integrate with key partners like title companies, lenders, insurance through APIs or referral links ￼. For MVP, we may simply list recommended partners and have forms that send data to them (or emails). Later, full integration: e.g. push deal and buyer info to the title company’s system when a deal goes under contract (via API).
	•	Example: Title Integration – automatically create a title order when contract is signed, and allow title company to update status and upload documents back. Lending Integration – allow investors to apply for a loan pre-approval via a third-party API and display their pre-approved amount on their profile/deal view ￼. Insurance – allow getting an insurance quote on the property instantly.
	•	Loyalty Program for Investors – P3: Implement a rewards system where investors earn points or credits for actions: registering, attending a webinar, closing a deal, using a partner service, referring another investor, etc. These points could translate into discounts (e.g. reduced assignment fee on next deal, gift cards, etc.). This increases engagement and repeat usage.
	•	Referral Program – P2: Allow users (investors or agents) to refer others via an invite link. Track referrals and reward referrers (for instance, an agent gets a “Referral badge” or bonus if they bring in an external agent or listing that turns into a deal ￼; an investor might get credit if they refer another buyer who closes a deal).
	•	In-App Perks (Partnerships + Loyalty) – P3: Implement features like the Home Depot discount integration described in the persona ￼. For example, within the platform an investor can connect their profile to a Home Depot Pro account to receive negotiated discounts on materials. After closing a deal, a “Home Depot Cart” could be auto-generated with needed renovation materials and applied discounts. The platform might track usage of such perks – possibly giving the wholesaler or agent credit for activating it ￼ (feeding leads or vendor kickbacks).
	•	GTM (Go-To-Market) Support Features – P3: Because the platform is multi-tenant, supporting our internal sales/GTM team to onboard new wholesalers is a consideration. E.g., features to copy configurations from one tenant to another (template tenant setup), or a multi-brand management console where an admin (like our internal team) can oversee all tenants, especially if we have franchises or multiple brands to manage (this relates to “begin enabling multi-brand configurations” in roadmap ￼).

3.9 Micro-Frontends & Extensibility (Platform Architecture – Product Perspective)

(While largely technical, some product-level requirements ensure the platform is extensible and maintainable.)
	•	Independent Module Deployment – P1: Each major feature area (e.g. Marketplace browsing, Analytics dashboard, CRM integration panel, etc.) is built as a micro-frontend module that can be deployed without affecting the entire app. This ensures faster iteration and the ability to turn on/off features per tenant if needed. For example, if “Advanced Analytics” is not ready or not purchased by a client, that micro-frontend can be omitted.
	•	Consistent UI and Navigation – P1: Despite micro-frontends, maintain a unified look and feel. Use a shared design system (MUI + Tailwind config) for common components. The navigation should seamlessly link between modules (e.g. an investor moves from Marketplace to Notifications to Profile without feeling a boundary).
	•	Feature Toggles & Phased Rollout – P2: Ability to enable features for specific tenants or users (for beta testing, or tiered plans). For instance, the CRM integration adapter for Salesforce might be a premium feature toggled on for certain enterprise tenants.
	•	Third-Party Embeddable Widgets – P3: Provide a mechanism for tech partners to embed their UI. Perhaps via an iFrame or a plugin API in a micro-frontend. Ensure these can be sandboxed and don’t compromise the overall app security.

4. Feature Dependencies and Assumptions

Many features above have interdependencies. Here we summarize critical dependencies and assumptions:
	•	User & Org Management underpins everything (must-have first). Multi-tenancy design is fundamental and touches authentication, every service, and UI.
	•	Authentication & Authorization must be in place early (for any user-specific or secure feature).
	•	Deal Lifecycle features depend on Onboarding (investors must be onboarded to interact with deals) and on basic Messaging/Notification (to alert users of deal events).
	•	Bidding & Down Payments depend on having a payments integration and a stable offer submission system.
	•	Contract Generation depends on having document templates prepared and e-signature integration available.
	•	CRM Sync depends on establishing the integration framework (adapters, API credentials management) – likely a technical groundwork to be done before plugging in any specific CRM.
	•	Analytics dashboards depend on data collection from various activities. Early on, we must instrument key events (deal posted, viewed, offer made, etc.) so that data exists to report on.
	•	Loyalty/Rewards assume that partner integrations (Home Depot, lenders, etc.) are in place to track usage. Also depends on a points ledger system to record and redeem rewards.
	•	Multi-Tenant Isolation is an overarching requirement – any cross-tenant features (like deal sharing) must be carefully designed not to violate the isolation rules.
	•	Performance & Search (ElasticSearch): Using ElasticSearch for querying deals is intended to allow fast, full-text and geo search across a potentially large inventory. This will depend on setting up an ES cluster and a sync mechanism from PostgreSQL (likely an event or CDC-based sync). We assume we will implement basic search via Postgres first (for MVP with limited data) and introduce ElasticSearch indexing by the time we have more data (phase 2 or 3).
	•	Tech Stack Assumptions: The stack (TypeScript, React, Redux-Saga, Node/TypeORM, etc.) is a given. We assume developers are skilled in these and that we will set up a monorepo or appropriate repo structure to manage multiple services and frontends.
	•	AWS Infrastructure: Using AWS CDK implies we will define infrastructure (databases, containers, networks) as code. We assume AWS services (like ECS or EKS for containers, RDS for Postgres, perhaps ElastiCache for any caching, EventBridge or SNS for events, etc.) are available and within budget. This also means certain features (like using AWS Cognito vs rolling auth) could be considered – but given we need custom multi-tenant logic, a custom Node-based auth service might be used with JWTs.
	•	External Services for Dev: We will mock external integrations in development to avoid needing credentials and to simulate responses. For instance, have a dummy CRM API to test the adapter, or a fake payment service. In production, those will be toggled to real integrations with secure secrets injection.

5. Phased Implementation Roadmap (40+ Phases)

To deliver this complex platform, we will roll out features in phases, balancing technical foundations with business-driven functionality. Below is a detailed roadmap with at least 40 phases. Each phase is labeled with a focus (Tech vs Business or both) and highlights of deliverables. The phases are sequenced by priority, but some may be developed in parallel if resources allow.
	1.	Phase 1: Project Setup & Core Architecture (Tech) – Initialize the project with a monorepo structure. Set up the build system with Vite and Next.js integration, configure TypeScript, ESLint, Jest, and basic CI pipeline. Establish Docker container setup and AWS CDK project skeleton for infrastructure provisioning. Deliverable: Hello-world service deployable via CDK, repository standards in place.
	2.	Phase 2: Authentication & Multi-Tenancy Framework (Tech) – Implement the user authentication service (using JWT or session with Next.js). Design the multi-tenant data model: create entities for Organization (Tenant), User, UserRoles, etc., with tenant context. Enforce that all database queries via TypeORM include a tenant filter (e.g., using entity scoping or query hooks). Deliverable: Users can sign up/login, belong to an Organization; global admin can create an org.
	3.	Phase 3: RBAC Permission Model Baseline (Tech) – Define core roles (Org Owner, Admin, Agent, Investor) and their permissions. Implement middleware in APIs to check permissions (possibly a library or custom guard). Ensure every API endpoint requires a tenant ID and user token (aligning with rule “tenant context mandatory for all API calls” ￼). Deliverable: Permission checking service or module, with an initial permission matrix for basic operations.
	4.	Phase 4: Basic Frontend Shell and Micro-FE scaffold (Tech) – Implement the main Next.js shell application with React, and set up module federation or an equivalent to host micro-frontends. Create a basic navigation layout and placeholder pages for key sections (Marketplace, Deals, Investors, etc.). Ensure theming/branding can be swapped per tenant (e.g., via context or CSS variables). Deliverable: The app can route between a couple of placeholder pages, demonstrating micro-frontend loading (even if just dummy components for now).
	5.	Phase 5: Database Setup & TypeORM Entities (Tech) – Set up PostgreSQL database via AWS RDS. Create TypeORM entities for core objects: Organization, User, InvestorProfile, Property/Deal, etc., aligned with the multi-tenant structure. Possibly implement database migrations infrastructure. Deliverable: Running DB with initial schema and connection from the backend.
	6.	Phase 6: Onboarding Flow – Investor Registration (Business) – Develop the frontend pages and backend endpoints for Investor sign-up. Include fields for profile and any required disclosure agreements. Send a confirmation email upon registration (integrate a simple email service, e.g. AWS SES). Introduce the concept of unlocked vs locked investor in the data model (flag). Deliverable: A new investor can self-register under a tenant’s marketplace (either by choosing from a list of marketplaces or via an invite link URL).
	7.	Phase 7: Org Admin Console – User Management (Business) – Provide an interface for Org Owners/Admins to invite users (agents or investors) and manage pending sign-ups. Also, allow the admin to “unlock” investors. Include listing of all users in their org with roles and statuses. Deliverable: Admin can view their organization’s user list, approve investors, assign roles.
	8.	Phase 8: Deal Management Backend – CRUD API (Tech/Business) – Implement backend services for deals: create, read, update, delete property listings, with all relevant fields (address, price, etc.). Include business logic such as default status = draft on creation, and only certain roles can create (Acquisition Agent/Admin). Deliverable: REST endpoints like POST /api/deals, GET /api/deals/:id, etc., secured by role.
	9.	Phase 9: Deal Management UI – Create & Publish (Business) – Build the frontend form for agents to create a new deal and a list view of deals. Allow uploading images (integrate an S3 bucket via AWS for storing images and a signed URL upload mechanism). Implement the “Publish” action that sets a deal status to active and triggers a notification (stubbed). Deliverable: An agent can log in, create a deal with details and photos, and publish it to make it visible to investors of that org.
	10.	Phase 10: Investor Marketplace UI – Browse & Search (Business) – Develop the investor-facing marketplace page. Show a list of published deals with basic info and a search bar/filters. For now, implement search by querying Postgres (later to be replaced by ElasticSearch). Include permission check: if investor is not unlocked yet, show limited info (e.g., hide address). Deliverable: An unlocked investor can see available deals, filter by criteria, and click to view details.
	11.	Phase 11: Deal Detail Page & Contact Agent (Business) – Implement the property detail page. Show full info, images gallery, and an “Interested” or “Contact Agent” button that opens a message modal or provides agent contact info. If the user is locked, perhaps show a prompt “Request access from agent”. Deliverable: Investors can view a detailed page for a deal and send a message expressing interest.
	12.	Phase 12: In-App Messaging MVP (Tech/Business) – Build a simple messaging service: when an investor sends a message on a deal, store it and notify the agent. Provide an inbox view for agents showing messages per deal or investor. For now, this can be simple (no real-time, agent refreshes to see new messages). Deliverable: Agents can see investor inquiries and respond within the app.
	13.	Phase 13: Email Notifications (Tech) – Integrate an email service (e.g., using AWS SES or SendGrid) to send key notifications. Implement triggers for: new investor registered (notify agent/admin), investor unlocked (notify investor), new deal published (notify all investors or those matching criteria – can start with all for simplicity), and message alerts (notify via email if user offline). Deliverable: Basic notification emails are being sent and can be configured in code (later make it more dynamic).
	14.	Phase 14: Search & ElasticSearch Integration (Tech) – Set up ElasticSearch and create an indexing pipeline for deals. Possibly use AWS OpenSearch. Each published deal should be indexed (title, description, location, etc.). Update the search on marketplace page to query ES for better performance and full-text capability. Deliverable: Search results become faster and more relevant, allowing text queries and possibly geo distance queries for location.
	15.	Phase 15: Offer Submission Workflow (Business) – Enable investors to submit an offer on a deal. On the UI, provide a form to enter offer amount (if not fixed price) and any notes. On backend, create an Offer entity linked to deal and investor. If the platform model is first-come-first-serve, then submitting an offer can automatically lock the deal for that investor pending payment. If auction model, store it and mark as bid. For MVP, we handle simple offer -> agent manually accepts. Deliverable: Investors can place offers; the system records them and prevents other offers if one is pending acceptance.
	16.	Phase 16: Down Payment Handling (Tech/Business) – Integrate a payment API (e.g. Stripe) to handle collecting a down payment/earnest money when an offer is accepted. Possibly use Stripe Checkout or ACH transfer. If real integration is complex, at least simulate it (e.g. clicking “Pay Now” marks the payment as done). Ensure the offer acceptance process checks for payment status. Deliverable: Agents can accept an investor’s offer, which then prompts the investor to make a payment. The deal status changes to Under Contract only after payment confirmation.
	17.	Phase 17: Contract Generation Template (Tech/Business) – Create a basic contract template (e.g. as a PDF form or HTML->PDF) for the assignment contract. Fill in the deal specifics and buyer/seller info. For this phase, just generate the PDF and store it; signing can be manual or out-of-band. Deliverable: A PDF contract is generated when a deal goes under contract and is accessible to admins (and possibly emailed to parties for signature).
	18.	Phase 18: Multi-Tenant Data Validation & Security Audit (Tech) – At this point, with core flows in place, conduct a thorough review to ensure no data is leaking across orgs. Write unit/integration tests specifically for multi-tenancy (e.g. user from Org A trying to access Org B’s deal via API should be denied). Implement any needed fixes (like adding tenant checks we missed). Deliverable: Test suite proves isolation; security checklist for MVP passes.
	19.	Phase 19: MVP Launch (Business) – Deploy the platform with one or two pilot wholesaler tenants (e.g. an internal brand like “Big State Home Buyers” as mentioned ￼). This isn’t a development phase per se, but a milestone. Collect feedback from pilot usage to plan next improvements. Deliverable: Live system used by real users (small scale), initial KPI data gathering.
	20.	Phase 20: CRM Integration Framework (Tech) – Design the adapter interface for CRM systems. Define a common data model for leads/investors and deals that external CRMs can map to. Implement a base CRM service that can call out to specific adapters (Salesforce, etc.). For now, perhaps implement a Salesforce adapter (client) that can push new investor contacts into SF and pull updates. Provide UI in org settings to store OAuth tokens or API keys for CRM. Deliverable: A wholesaler admin can connect their Salesforce account; when an investor registers or a deal closes, data syncs to Salesforce (basic fields).
	21.	Phase 21: Analytics Event Tracking (Tech) – Instrument the system with event logging for key actions (deal viewed, offer made, deal closed, user logged in). Use a tool or custom pipeline (perhaps sending events to a queue or a service like Amazon Kinesis or Segment). These events will feed the analytics dashboards. Deliverable: Events are being recorded and stored (maybe in a data warehouse or at least a separate DB table) for later analysis.
	22.	Phase 22: Investor & Deal Analytics Dashboard (Business) – Create a basic analytics page for the wholesaler: show counts of active deals, total investors, offers in last week, etc. Use charts to visualize trends. This first version can be limited but should already deliver value (e.g., “You had 5 new investors and 10 offers this month”). Deliverable: Org users can see a dashboard with key performance metrics (data coming from the events of Phase 21).
	23.	Phase 23: Contract E-Signature Integration (Tech) – Now integrate with an e-signature provider to replace the manual signing. Use their API to send the generated PDF to investor and seller for signature. Track the status via webhook or polling. Once fully signed, mark deal as closed pending any final steps. Deliverable: Parties can electronically sign the contract generated by the system, and the signed copy is saved.
	24.	Phase 24: Compliance Enhancements (Business) – Add features for compliance: for example, ensure an investor has acknowledged a disclaimer before they can submit an offer (block action if not). Add a module for admin to upload state-specific legal docs (these could then attach to each contract as needed). Also, if required by any partner, integrate a quick AML/KYC check for investors who hit certain thresholds (possibly via a third-party service).
	25.	Phase 25: External Service Integrations (Title/Lending) MVP (Business) – Establish a minimal integration with a Title company and Lender: For example, when a deal goes under contract, automatically email a designated title company contact with the deal info. Likewise, if an investor indicated they want financing, email the lender partner. Essentially, this phase ensures the workflows with external parties are not purely manual. Deliverable: Title and lender partners are notified of transactions in a structured way (could be emails or a simple portal login for them to update status).
	26.	Phase 26: Mobile-Friendly Enhancements (Tech) – Refine the UI to ensure it’s fully responsive. Test key flows (deal browsing, messaging, offer submission) on mobile devices and fix any usability issues. Possibly prepare for a future dedicated mobile app by separating some logic (or at least ensure PWA compliance).
	27.	Phase 27: Performance Tuning & Scalability (Tech) – As usage grows (especially after pilot), optimize: set up caching (maybe use Redis or in-memory caching for frequent reads like deal lists), ensure ElasticSearch is tuned for queries, and use a CDN for images. Also implement pagination or infinite scroll for lists to handle large data sets.
	28.	Phase 28: Deal Sharing Across Tenants (Business) – Introduce the Deal Share Network feature ￼. Define how a wholesaler can flag a deal for sharing and what that means (perhaps it goes into a common pool where other wholesalers can opt-in to show it to their investors if they don’t have competing deals). Build the logic so that an investor from a different tenant can see the deal (but likely still only contact the origin wholesaler’s agent, or perhaps their own agent gets a referral cut). This is complex, so initial implementation could be limited to internal use (e.g. among a few sister brands). Deliverable: A shared deals section in the marketplace, with rules to avoid showing duplicates to investors if they overlap (one investor, one wholesaler per deal rule ￼).
	29.	Phase 29: Multi-Brand Theming & Configuration (Business) – Allow platform-level admins (our team) to configure branding per tenant: custom domain support (e.g. investor.NewWestern.com points to their marketplace), logo upload, color themes, and toggle features on/off per tenant (like enabling the CRM-lite module or not). Prepare for multi-brand support where some tenants might share infrastructure but have distinct brand settings ￼. Deliverable: Each organization can have its own theme and certain feature flags, managed via an admin UI.
	30.	Phase 30: CRM-Lite Module (Business) – For smaller wholesalers who don’t have an external CRM, implement a lightweight CRM within the platform ￼. This could extend investor profiles with statuses (e.g. new lead, contacted, hot, inactive) and tasks (follow-up calls, notes). Essentially give them basic CRM functionality so they can manage leads entirely in-platform if desired. Deliverable: An “Investor CRM” tab for an organization where they can track their investor outreach and status, without needing Salesforce.
	31.	Phase 31: Loyalty Points & Credits System (Business) – Build the backend for loyalty tracking. Create an entity for Rewards Account per investor (per tenant, or possibly global if we want points to accumulate across all marketplaces?). Define events that grant points (closing a deal, referring a friend, attending a seminar, using a linked service). Implement logic to accumulate points and a simple UI to show points balance. Deliverable: The system starts tracking points for certain activities and displays them on the user’s profile.
	32.	Phase 32: Partner Services Marketplace (Business) – Add a section or modal for Investor Services (post-purchase or pre-purchase). For example, a tab where investors can browse or sign up for Home Depot discount, find recommended contractors, find property managers, insurance quotes, etc. This requires compiling partner offerings. Some can be simple links or forms initially. Over time this could become a mini marketplace of services. Deliverable: Investors see a “Services” menu with at least a Home Depot integration link and a few partner offers, enriching the platform’s value prop.
	33.	Phase 33: AI-Powered Notifications & Preferences (Tech/Business) – Integrate a basic ML recommendation engine. For instance, use the data of what each investor has viewed or declined to refine which new deals to notify them about (content-based or collaborative filtering recommendations). Start with rules (if investor said “no pools”, filter those) then move to learned behavior. Also possibly implement an AI summary of new deals sent weekly, highlighting ones likely of interest to each investor. Deliverable: More personalized notification system that improves engagement (as evidenced by persona’s note that notifications felt “tuned to me” ￼).
	34.	Phase 34: Agent AI Assistant Tools (Tech/Business) – Introduce AI to help agents manage workload. For example: an AI that scans incoming investor messages to suggest replies, or an AI scheduling assistant that finds slots for property tours. A concrete start could be an AI that auto-drafts responses to common questions (using a GPT-like service) for the agent to approve. Another could be analyzing which investors the agent should call today (based on inactivity or new deals) – essentially creating a prioritized call list. Deliverable: A new “AI Suggestions” widget in the agent dashboard that surfaces recommended actions or auto-generated email drafts.
	35.	Phase 35: Training and Knowledge Base (Business) – Add an internal knowledge base or training module accessible to agents. Include compliance training materials and maybe interactive quizzes. This addresses the need for ongoing education (like the persona who takes a morning quiz to stay sharp ￼). Gamify it with badges for completion. Deliverable: Agents can access training content and the system tracks their completion (which could tie into compliance if certain training is mandatory).
	36.	Phase 36: Extended Partner Integrations (Business) – Expand integrations to more partners as per roadmap: e.g., integrate PadSplit or similar service if wanting to offer room-by-room rental options, connect with contractor networks like Thumbtack for finding local contractors ￼, or integration with property listing sites if an investor wants to list a flip. Essentially continue the build/partner approach ￼: if there’s a strategic partner that adds value, incorporate them via API or SSO. Deliverable: At least one new partner integration beyond title/lender, e.g., a module where an investor who is planning to rent out can connect to a partner providing tenant placement.
	37.	Phase 37: Open API for Tech Partners (Tech) – Document and expose the platform’s APIs to third-party developers. Create API keys or OAuth for external apps. This includes listing available REST endpoints, webhooks for events (like “deal closed” notifications), and possibly a developer portal. By doing this, we allow external tech partners to build on the platform (for example, someone might develop a specialized analytics app using our data). Deliverable: API documentation published, and the ability for an external system to securely pull data (with tenant-scoped credentials).
	38.	Phase 38: Quality, Load Testing & Hardening (Tech) – Before scaling to many tenants, conduct thorough testing: simulate high load (many simultaneous deal searches, multiple auctions running), and use results to optimize (perhaps enable auto-scaling of services, optimize queries, add indices). Also perform security penetration testing to catch any vulnerabilities. Deliverable: Performance test report and applied optimizations; security test report and fixes.
	39.	Phase 39: Production Monitoring & Alerting (Tech) – Finalize the monitoring setup: ensure all microservices have dashboards for CPU/memory, set up alerts for error rates or response time spikes. Use AWS CloudWatch, Elasticsearch/Kibana, or third-party APM tools. Implement structured logging and traceability (correlation IDs for requests across services) to aid in troubleshooting. Deliverable: Ops team (or dev team) gets real-time alerts for any critical issue and has the tools to diagnose problems quickly in production.
	40.	Phase 40: Full Launch & Continuous Improvement (Business/Tech) – Officially launch the platform to all intended user groups and onboard more tenants (multiple wholesalers, including possibly external ones). Gather feedback and usage data to plan the next iteration of features (which might include refining anything missed or adding “could-have” features like advanced bidding algorithms or further automation). From here on, move into an Agile continuous delivery model, regularly shipping improvements. Deliverable: Platform is live with multiple organizations and hundreds/thousands of users, and a backlog of enhancements managed in sprints.

Note: The above roadmap ensures that by Phase ~15-18, we have a working MVP covering the must-have features ￼ (deal management, investor management, marketplace browsing, auth, messaging/notifications, basic integration hooks). Phases 19-30 then add the should-haves (CRM sync, analytics, contracting, down payments) ￼ and some early could-haves. Phases 31-40 incorporate the remaining could-haves and expansion: document automation, loyalty, advanced bidding ￼, plus scaling to more tenants and richer ecosystem integration. This phasing aligns with the strategy outlined in the Marketplace Initiative document ￼ ￼, ensuring technical foundations are laid early and business value is delivered incrementally. Each phase is scoped to be achievable in a relatively short iteration (where possible), to show continual progress.

⸻

Technical Requirements Document (TRD) – Unified Real Estate Investment Platform

1. System Architecture Overview

The platform will adopt a microservices architecture on the backend and a micro-frontend architecture on the frontend, all deployed to AWS via containerization. Key characteristics of the architecture:
	•	Event-Driven Microservices: Backend services communicate primarily through asynchronous events (e.g., using AWS EventBridge or SNS/SQS topics). For example, when an offer is submitted, an “OfferSubmitted” event is emitted which other services (analytics, notification service, etc.) can consume. This decouples services and improves scalability.
	•	REST and tRPC APIs: The system exposes a RESTful API for external consumers and uses tRPC (TypeScript RPC) for efficient type-safe communication between frontend and backend (and potentially between microservices internally). Both API styles follow a consistent JSON format per the JSON-C (Google JSON Style Guide) standard ￼ ￼ for request/response envelopes. This means every response will have a top-level structure with either a data object or an error object, along with metadata like apiVersion, id, etc., ensuring a uniform “look and feel” across all services ￼ ￼.
	•	Containerization & Deployment: Each microservice and micro-frontend runs in a Docker container. We use AWS CDK to define and provision infrastructure (likely ECS Fargate for services, ECR for images, RDS for Postgres, OpenSearch for ElasticSearch, S3 for static assets and documents, etc.). CDK also defines networking (VPC, subnets), security groups, and IAM roles for least-privilege access between services.
	•	Scalability: The architecture will support horizontal scaling. For example, if the load on the deals service increases, we can spin up more containers to handle it. AWS Application Load Balancers or API Gateway will distribute requests. Event queues decouple load bursts (one service can queue events if the consumer is temporarily slow).
	•	Fault Isolation: Each microservice is independently deployable and has its own database tables or schemas (though all using the same Postgres instance for simplicity, with schema separation or tenant tagging). A bug in one service (e.g., CRM sync) should not crash the entire system. Frontend micro-apps are also isolated – a failure in the Analytics module shouldn’t break the Marketplace browsing module.
	•	Tech Stack Enforcement: Use Node.js (TypeScript) for all backend services (ensuring shared code patterns and easier knowledge sharing). Use TypeORM for data access (with repositories or Active Record patterns, configured to include tenant context on queries). Use Zod for runtime schema validation of inputs/outputs, complementing TypeScript’s static typing. React + Redux-Saga on the frontend ensures predictable state management, and TanStack Query (React Query) will handle server state caching and synchronization for API calls.

Below is an outline of key microservices (back-end) and micro-frontend modules (front-end):

Backend Microservices:
	1.	Identity & Access Service (IAM Service): Manages users, authentication (likely via JWT issuance on login), password resets, and verification. Also enforces RBAC/ABAC decisions (could be a library used by other services or a central service that can be queried for permission checks). It stores user accounts, hashed passwords (if not using an external IdP), roles, and org memberships. Tech: Node/TS, Express or tRPC server, TypeORM (User, Org, Role entities), JWT, possibly OAuth2 if social login considered.
	2.	Organization Management Service: Handles org creation, org-level settings (branding, preferences, feature flags for that org). Might be part of IAM or separate. Ensures multi-tenant constraints – e.g., injecting tenant context into other services’ calls.
	3.	Deal Service: Core service managing property deals. Provides endpoints for creating/updating deals, querying deals (with filters). Implements business rules around status transitions (Draft -> Published -> Under Contract -> Closed). Responsible for indexing deals into ElasticSearch (could produce an event that a separate Search Service handles, or directly call ES on changes).
	4.	Investor Management Service: Manages investor profiles and their relationships to orgs (which investors belong to which wholesaler). Handles onboarding state (locked/unlocked, preferences). Could also handle the CRM-lite functionality (notes, contact status) for investors. This service ensures that when an investor is unlocked by an agent, the state is updated and other services (like Deal Service) respect it (e.g., search results might exclude locked investors or mask info for them).
	5.	Offer/Bidding Service: Handles the offer process. It receives offer submissions from investors, records them, and possibly locks the deal or triggers an auction process. If implementing auctions, this service would run the auction logic (timers, highest bid tracking). It coordinates with Payment service for deposit verification.
	6.	Payment Service: Integrates with external payment gateway to handle transactions (down payments, any other billing). It should not store sensitive card data itself (use tokenization from Stripe or similar). It listens for events like “OfferAccepted” to request payment, and emits events like “PaymentReceived” to finalize deal status.
	7.	Contract & Document Service: Responsible for generating documents (contracts, PDFs) using templates. It might use a library like PDFKit or an external templating service. Also manages storage of documents (likely uploads final docs to S3). It might integrate with e-signature API and listen for callback events (like “DocSigned”).
	8.	Notification Service: Handles email/SMS dispatch. It may consume events (NewDealPublished, MessageReceived, etc.) and then format and send out notifications via third-party providers. Could also handle in-app notification storage (so users see a notifications list when logged in).
	9.	Messaging Service: Manages in-app messaging between investors and agents. Could use websockets or long polling for real-time updates. This service stores message threads, ensures only authorized users (participants of the conversation and relevant org members) can access the messages.
	10.	Analytics & Reporting Service: Aggregates events and provides data for dashboards. This might involve a small data warehouse or simply on-the-fly queries. For MVP, might just read from the primary DB (with indices) to produce summary stats. Later, could evolve to use Amazon Redshift or time-series DB for analytics. Also, it can expose endpoints for the front-end dashboards.
	11.	Integration Hub Service: A service that hosts the CRM adapters and partner integrations. For each external system (Salesforce, HubSpot, a specific Title company API, etc.), it implements the logic to communicate with that system (using stored credentials). It provides a uniform interface to other services: e.g., the Investor Service doesn’t talk to Salesforce directly; it calls Integration Hub like POST /crm/syncInvestor which then uses the appropriate adapter. This service also handles scheduling sync jobs (e.g., nightly full syncs or instant sync on certain triggers).
	12.	Search Service: (Optional, could be part of Deal Service) – abstracts ElasticSearch operations. Provides a dedicated endpoint for search queries, which queries the ElasticSearch index and returns results. This decouples front-end from ES specifics and allows adding caching or result post-processing (like boosting certain deals).
	13.	Media Service: Handles file uploads and access (for photos, documents). For security, it could issue pre-signed URLs for S3 so the front-end can upload/download securely. This might be a lightweight service or just a part of the infrastructure.
	14.	Admin/Platform Management Service: (Optional initially) – used by the platform operator to manage the whole system. E.g., view all tenants, usage statistics, manage feature flag defaults, etc. This would be internal.

Each service will have its own database tables, but physically we will use a single PostgreSQL instance with multiple schemas or clear tenant foreign keys. The data model will be designed for multi-tenancy:
	•	There will be either a tenant_id field on all key tables (approach: single database, shared schema, tenant_id column with indexing and possibly row-level security policies to enforce isolation), or separate schemas per tenant (approach: schema-per-tenant). Given moderate complexity and need for cross-tenant querying for internal analytics, the single schema with tenant field is likely. We will ensure that every query includes WHERE tenant_id = X (enforced by our repository patterns or an ORM global filter).
	•	Some reference tables (like a list of States, ZIP codes, etc.) can be system-owned (global) with no tenant_id. But any tenant-specific data (deals, users, offers) must carry a tenant identifier.
	•	A global “master” schema might contain cross-tenant aggregate or an “internal” set of tables only accessible by platform admin (e.g., to track all users across tenants for our internal metrics).
	•	We will coordinate with the global data classification model in design: classify which data is tenant-owned vs system-owned vs internal-only ￼ ￼. For example:
	•	Tenant-owned: Deals, Investor contacts, etc. – all have tenant scope.
	•	System-owned: Perhaps user accounts that span tenants (if an investor joins two marketplaces, do they have one account or two?). Likely one account linked to multiple orgs, so the core User might be system-owned, but a linking table UserOrg is tenant-owned.
	•	Internal-only: Logs, usage stats that are for our eyes only, etc.

Frontend Micro-Frontend Modules:
We will split the front-end application into modules that align with business domains, each possibly a standalone build:
	1.	Marketplace Module (Investor Portal): Handles browsing deals, viewing details, investor profile & preferences. This is loaded for investor-type users. It’s the public-facing UI of each tenant’s marketplace.
	2.	Deal Management Module: Used by agents/admins for creating and managing deals. Includes forms for deal input and lists of deals with edit capability.
	3.	CRM-Lite / Investor Management Module: Interface for agents/admins to manage investor contacts, see their statuses, perhaps assign them to deals or track follow-ups. (If an external CRM is integrated, this module might show sync status or minimal data with a link to the CRM).
	4.	Offer & Transaction Module: Provides UI for offer submission, viewing offers (for agents), and managing the transaction checklist through closing. Could include contract signing progress.
	5.	Messaging Module: Provides the messaging UI (inbox, chat windows). Could be part of a common shell or separate.
	6.	Analytics Dashboard Module: The reporting screens for analytics. Possibly separate since the charts libraries etc. could be heavy.
	7.	Admin Settings Module: For organization-level settings, user management, branding config, integration settings (API keys for CRM, etc.). Likely only accessible to Org Owners/Admins.
	8.	Global Shell & Navigation: This is the host app that ties it all together. It handles routing, top nav, and loading of the appropriate micro-frontend modules based on route/role.

Micro-Frontend Integration: We’ll likely use Webpack Module Federation or a similar technique (supported in Vite via plugins ￼) to load remote modules at runtime. Each module will be a separately deployed artifact (for instance, hosted on S3 or behind a CDN as a set of JS files). The shell will fetch the module bundle when needed. This allows independent deployment – e.g., updating the Analytics module without redeploying the rest. We must version these carefully to avoid incompatibilities in shared state (Redux store) or shared components. We will maintain a shared component library (for common UI elements) that all modules use to ensure consistency.

2. RBAC/ABAC Permission Model

Roles Definition: We define roles in a hierarchy (if applicable) or separate per tenant:
	•	Platform Admin (internal) – not a tenant role, but for our support staff: can access any tenant’s data (for support) via internal tools. This role is extremely sensitive and only in internal admin interface, not in main app for customers.
	•	Organization Owner (Account Owner): Top role within a tenant. Typically the person who onboarded the wholesaler onto the platform. Has all permissions on their tenant’s data: manage users, deals, view financial info, etc.
	•	Admin (Org Admin): Can do most things the owner can except maybe billing or removing the owner. They manage daily operations, user invitations, etc.
	•	Disposition Agent (Sales Agent): Can create/edit deals, see investor list (maybe only those they are associated with or all – might be configurable), communicate with investors, accept offers.
	•	Acquisition Agent: Can input deals (create property entries), possibly not allowed to publish (that might be dispo’s job) depending on workflow. Can see deals they sourced.
	•	Investor (Buyer): Can view published deals, make offers, and communicate with agents. They cannot see other investors or sensitive internal data.
	•	Service Partner: (If they log in) could be a limited role that only can see deals assigned to them for service (e.g., a Title partner sees the deals for which they are the title provider). Alternatively, they might not have a login at all in MVP (just email integration), but if they do, we’ll define a role per type (Lender, Title, etc.) that grants access only to relevant sections.
	•	Guest/Prospect: (Optional) An investor who registered but not yet unlocked might be considered a “Prospect” role which has very limited rights (can only see teaser information).

Role Permissions Matrix: (to be documented in detail in implementation)
We will maintain a matrix mapping each role to allowed actions (Create/Read/Update/Delete on each resource type, plus specific actions like “Accept Offer”). This matrix can be implemented in code or stored in a config. For example:
	•	Only OrgOwner/Admin can invite new users (create user in their org).
	•	Only Admin can change org settings.
	•	Agents can CRUD deals (their own or all, depends on policy).
	•	Investors can read deals (if published and if unlocked), create offers (if unlocked), read their own offers, send messages, etc.
	•	Service Partners can update certain fields on deals (like title status) but not see other info.

We will enforce these with:
	•	Backend checks: Every service endpoint will check the user’s role (from JWT or session) and the target resource’s tenant and attributes. For instance, if an agent tries to edit a deal, the service will verify that the deal’s tenant_id matches the agent’s tenant AND that the agent has the role that permits editing deals. If not, return a 403 Forbidden.
	•	We will also incorporate ABAC (Attribute-Based Access Control) rules for finer control ￼. For example:
	•	Rule: Disposition agents can only see offers on deals that belong to them or that are unassigned. We store an attribute like deal.assignedAgentId. The policy: agent can read an offer if offer.deal.assignedAgentId == agent.userId OR offer.deal.tenantId == agent.tenantId AND agent.role == Admin (so admins see all offers in their org, agents see only theirs).
	•	Rule: Investors can only view deals where deal.status == Published (no viewing draft or other states) AND either deal.tenantId == investor.tenantId (normal case) OR deal.sharedWithTenantIds includes investor.tenantId (for shared deals). And the investor must have investor.unlocked == true to view full details.
	•	Rule: Prevent cross-tenant function calls entirely, unless a feature explicitly allows (like deal sharing, which is handled in a controlled way).
	•	The architecture team will enforce having a reference for RBAC/ABAC that all devs use when adding features ￼. Possibly create a library or middleware to simplify checking these rules, to ensure consistency across services ￼.

Implementation Approach: We can use a library or model similar to AWS’s ABAC with tags or something like Oso (an open-source policy engine) to define these rules. Or simply hard-code critical rules and systematically include checks.
We will also include the tenant context in all service calls and DTOs to make sure the context is never lost ￼ ￼. For example, an internal service-to-service event or call will carry tenantId as part of the payload so the receiving service knows the scope.

Testing & Verification: We’ll write unit tests for permission logic, and also possibly integrate an automated security test that tries role escalation (ensuring e.g. an investor token cannot access an admin API).

3. Data Model and Multitenancy Principles

Designing the data model with multi-tenancy and scalability in mind:
	•	Tenants and Schema: We choose a single database, shared schema with a tenant_id column on all multi-tenant tables. The tenant_id will be a foreign key referencing an Organizations table (or simply stored as an ID if we use a separate schema per tenant approach). We considered separate schema or DB per tenant for isolation, but given the need for deal sharing and cross-tenant analytics, a shared schema with tenant keys is more practical. We will implement PostgreSQL Row-Level Security (RLS) as an extra guard: attach a policy to tables that only allows SELECT/UPDATE/DELETE where tenant_id = current_user’s tenant context. This way, even if a query is accidentally missing a filter, the DB itself will prevent cross-tenant data from leaking.
	•	Entity Relationships: Key entities include:
	•	Organization (Tenant): id, name, settings (JSON for config like theme), etc.
	•	User: id, global user account info (name, email, hashed password, etc.). A user can belong to multiple orgs – e.g. an investor could invest in multiple marketplaces; an agent likely only in one. We manage this via a join table UserOrganization with roles. So UserOrganization has fields: userId, orgId, role.
	•	Investor Profile: If we need investor-specific info per org (like their preferences, status with that org), this could either be in UserOrganization or a separate InvestorProfile table keyed by (userId, orgId). Possibly combine for simplicity.
	•	Property/Deal: id, tenant_id, title, description, price, ARV, status, createdBy (user), assignedTo (agent), etc. plus relational fields linking to related tables (e.g., maybe a table for photos or documents). Use a UUID or similar for id (to be unique across tenants as well).
	•	Offer: id, tenant_id (should match the deal’s tenant_id for consistency, though technically if we allow cross-tenant offers, the offer might belong to investor’s tenant or deal’s tenant – but easier is to treat the “deal owner” as authoritative tenant). Fields: dealId, investorId (userId of investor), amount, status, createdAt.
	•	Message: id, tenant_id, senderId, receiverId, dealId (nullable if general), content, timestamps.
	•	Notification: id, tenant_id, type, content, userId (who it’s for), read/unread.
	•	Document: id, tenant_id, dealId, type (contract, etc.), storagePath (S3 key), maybe a JSON of metadata.
	•	PartnerIntegration: id, tenant_id, type (e.g. “Salesforce” or “TitleCo”), credentials (likely encrypted), settings (like field mappings).
	•	Transaction (Closing) Checklist: could be a table or JSON on deal for tasks required (could also generate tasks table).
	•	RewardTransaction: if implementing loyalty, table of points earned/redeemed with userId, orgId, points, description, date.
	•	Isolation and Shared Data:
	•	Private (tenant) data: Most of the above are tenant-specific.
	•	Shared data: If an investor is in multiple orgs, the User account is essentially shared (global). But their activity in one org is isolated from another. We consider the user’s membership in each org separate. For sensitive cases like messaging or notifications, those are scoped by org.
	•	There might be a concept of a global investor ID that ties the same person across orgs for internal tracking (like if one big buyer is active in 3 marketplaces, our company might want to see that). The system architecture allows that via the single User record. But each tenant will only see the user’s activity within their org.
	•	Deal Sharing: How to model a deal visible to multiple orgs? We have options:
	•	Create a copy of the deal in each shared-to tenant (not ideal for syncing).
	•	Or have a join table like DealShare (dealId, sharedWithOrgId). The primary tenant_id of the deal remains the owning org. Other orgs can query deals where there’s a share record for their org. This requires queries to join or an explicit service method to fetch shared deals. We will likely implement something like this for Phase 28, ensuring one deal can have multiple visibleToTenants.
	•	Data Partitioning: If scale grows massively, we might consider sharding by tenant (like putting different tenants in different databases). Our design should keep that in mind (abstract data access sufficiently), but initially not needed.
	•	Search Index (ElasticSearch): The index for deals will include tenant_id as well. The search service will always filter by tenant scope (plus any shared deals logic). If we allow cross-tenant search (maybe an investor toggling “show me network deals” which means search across multiple org indices), that will be implemented carefully via the sharing mechanism.

4. API Specifications (REST & tRPC)

We will design a clear set of RESTful endpoints for external use, and a parallel set of procedures for tRPC for internal use (front-end to back-end). They will follow consistent conventions and versioning:

General Conventions:
	•	Base URL likely /api/v1/ for REST. Each microservice might have its own prefix (e.g., /api/v1/deals/... for Deal service routes if exposed directly; or we might funnel through an API gateway).
	•	Use JSON-C style envelope for all responses. Example for a successful GET deal request:

{
  "apiVersion": "1.0",
  "id": "req-12345",
  "data": {
     "kind": "Deal",
     "item": {
        "id": "deal_abc123",
        "title": "3-bed Fixer Upper",
        "price": 150000,
        "status": "Published",
        "tenantId": "org_999",
        ...
     }
  }
}

If error:

{
  "apiVersion": "1.0",
  "id": "req-12345",
  "error": {
    "code": 403,
    "message": "Forbidden",
    "errors": [ { "reason": "InsufficientPermission", "message": "You cannot access this resource" } ]
  }
}

This format aligns with Google JSON guide (reserved top-level fields like data, error, etc.) ￼ ￼.

	•	HTTP status codes are used appropriately (200 for success with data, 4xx for client errors, 500 for server errors). But the response body still follows the envelope convention (with error code mirrored inside).
	•	For tRPC, since it’s not HTTP-centric (calls happen over a persistent connection or HTTP but marshalling is internal), we’ll ensure the same data shape is used, but tRPC can allow direct function calling. tRPC procedures will be defined with input/output schemas (Zod schemas) that mirror the REST inputs.

Key Endpoint Examples:

User & Auth (Identity Service):
	•	POST /api/v1/auth/register – Registers a new user (investor). Input: user details, org context (maybe invite code or org ID to join). Output: user data or verification needed.
	•	POST /api/v1/auth/login – Authenticates and returns a JWT token (if stateless) or session cookie. After login, all calls require the token.
	•	GET /api/v1/orgs/{orgId}/users – [Admin only] List users in my org.
	•	POST /api/v1/orgs/{orgId}/invite – [Admin] Invite a user (sends email with link).
	•	PUT /api/v1/users/{userId} – Update profile (if self or admin).
	•	GET /api/v1/users/me – Get current user profile and roles (including which orgs they belong to).

Deal Service:
	•	GET /api/v1/deals – List deals accessible to the user. For an investor, this returns all published deals in their org (and perhaps shared deals to their org). Query params can filter by status, price, etc.
	•	GET /api/v1/deals/{dealId} – Get details of a single deal. (Checks tenant and if user can view).
	•	POST /api/v1/deals – Create a new deal (Agent only). Body: deal data (property info). Might allow a flag publish: true to immediately publish if needed or that could be separate.
	•	PUT /api/v1/deals/{dealId} – Update a deal (Agent/Admin).
	•	DELETE /api/v1/deals/{dealId} – Delete deal (perhaps only if draft; rarely used).
	•	POST /api/v1/deals/{dealId}/publish – Action to publish a deal (could also be a field in PUT).
	•	POST /api/v1/deals/{dealId}/share?targetOrg=X – Share deal with another org (Admin only, if allowed).
	•	GET /api/v1/deals/shared-with-me – For an org user, list deals from other orgs shared to this org.

Search Service (or extended Deal):
	•	GET /api/v1/search/deals?q=...&filters... – Search endpoint returning deals (limited fields for performance perhaps). This will use ElasticSearch behind the scenes.

Investor/CRM Service:
	•	GET /api/v1/investors – [Agent/Admin] List investors in my org (with filters like status).
	•	GET /api/v1/investors/{investorId} – Get investor profile (if belongs to org).
	•	PUT /api/v1/investors/{investorId} – Update investor info or status (e.g., mark as VIP, or add notes if CRM-lite).
	•	POST /api/v1/investors/{investorId}/unlock – Action for agent to unlock investor access.
	•	Maybe GET /api/v1/investors/me/preferences – investor’s own saved preferences.
	•	PUT /api/v1/investors/me/preferences – update criteria for alerts.

Offer/Bidding Service:
	•	POST /api/v1/deals/{dealId}/offers – [Investor] Submit an offer. Body: {amount, message, etc.}.
	•	GET /api/v1/deals/{dealId}/offers – [Agent/Admin] List offers on that deal (if permission).
	•	POST /api/v1/offers/{offerId}/accept – [Agent] Accept an offer (triggers contract generation & payment).
	•	POST /api/v1/offers/{offerId}/reject – [Agent] Reject or if multiple offers scenario.
	•	If auction style: maybe GET /api/v1/deals/{dealId}/bids for current high bid, and a websockets channel for live updates.

Payment Service:
	•	POST /api/v1/offers/{offerId}/pay – [Investor] Make payment for an accepted offer’s deposit. (This might redirect to Stripe or handle token).
	•	GET /api/v1/offers/{offerId}/payment-status – Poll payment status (or push via webhook to notify PaymentReceived).

Contract & Document Service:
	•	GET /api/v1/deals/{dealId}/contract – Download the generated contract (PDF). (Permissions: only involved parties or org members).
	•	POST /api/v1/deals/{dealId}/contract/sign – [Investor] Sign the contract (this could be a redirect/integration with e-sign provider, or a callback handling).
	•	GET /api/v1/deals/{dealId}/documents – List documents attached (inspection, etc.).
	•	POST /api/v1/deals/{dealId}/documents – Upload a document (could also just use a presigned URL via a different endpoint).

Messaging Service:
	•	GET /api/v1/messages?dealId=X – Get messages for a specific deal thread (or all threads if no filter).
	•	POST /api/v1/messages – Send a new message. Body: {dealId, toUser (maybe optional if system determines agent vs investor), content}.
	•	Possibly endpoints for marking read, etc.

Notification Service:
	•	GET /api/v1/notifications – List of recent notifications for the logged-in user.
	•	POST /api/v1/notifications/mark-read – Mark notifications as read.

Analytics Service:
	•	GET /api/v1/analytics/summary – [Admin] Summary stats for their org (could also be broken into separate endpoints like /analytics/deals, /analytics/investors etc., but one summary is easier).
	•	GET /api/v1/analytics/timeseries?metric=deals_posted&interval=monthly – to get data points for charts.

Integration Hub (CRM & Partners):
	•	POST /api/v1/integrations/crm/test-connection – Test the saved CRM credentials.
	•	POST /api/v1/integrations/crm/export – Manually trigger sending of current data to CRM.
	•	POST /api/v1/integrations/title/order – If partner has an API: Place a title order.
	•	(Alternatively, these might not be exposed to front-end at all, except via setting config.)

tRPC Procedures:
We will define tRPC routes paralleling many of the above, but tRPC allows grouping by service and calling directly from the front-end with TypeScript types. For example, a tRPC procedure might be deals.publish({ dealId }) which internally calls the Deal Service. Or offers.submit({ dealId, amount }). The advantage is end-to-end type safety and no manual REST client coding for our own front-end. For external third parties, they will use REST.

We ensure both REST and tRPC respect the same business logic. Potentially, the REST controllers could be thin wrappers that call the same service functions as tRPC calls.

API Documentation: We will create an OpenAPI (Swagger) specification for all REST endpoints for external use. For tRPC, our team will rely on TypeScript interfaces.

Error Handling: Standardize error responses using JSON-C error object ￼. Define a set of error codes and reasons:
	•	400 Bad Request with validation errors (list each invalid field and reason).
	•	401 Unauthorized if token missing/invalid.
	•	403 Forbidden for permission denied (with reason like “InsufficientPermission”).
	•	404 Not Found if resource ID doesn’t exist or not accessible in tenant.
	•	409 Conflict for business rule violations (e.g., try to make an offer on a deal that’s already under contract).
	•	500 for unexpected errors (with a generic message, and an error ID for internal tracking).

Sample API Interaction Flow (Illustrative):
	1.	Investor hits POST /auth/login with email/password, gets a JWT in response (data.token perhaps) ￼ ￼.
	2.	Investor calls GET /deals with that token in header. The server, using tenant context from token, returns deals in JSON envelope ￼.
	3.	Investor calls POST /deals/{id}/offers with offer details. Response might be a 200 with data.item containing the created offer. If investor wasn’t unlocked, this might return a 403 error with reason “NotUnlocked”.
	4.	Agent receives a server-sent event or checks GET /offers?dealId=id to see offers, then calls POST /offers/{offerId}/accept.
	5.	That triggers an event; investor could be notified via a notification or by having to call GET /offers/{id} and see status changed.
	6.	Investor then calls POST /offers/{id}/pay (or front-end redirects to Stripe).
	7.	Meanwhile, OfferAccepted event triggers contract creation. Agent can call GET /deals/{id}/contract after a bit to retrieve it.
	8.	After e-sign, a webhook triggers our contracts.signCallback which sets deal status closed. The agent sees in their GET /deals/{id} that status is now Closed.

Each of these steps involves the corresponding service and shows the interplay through events and APIs.

5. DevOps: CI/CD Pipeline, Testing, and Release Strategy

CI/CD Pipeline: We will implement continuous integration and deployment using tools like GitHub Actions or Jenkins, orchestrated through AWS CDK:
	•	Every git push triggers CI: run ESLint for code quality, run Jest test suites (with coverage thresholds enforced, e.g. 80% coverage minimum).
	•	If tests pass and code is merged to main branch, CD pipeline kicks in: build Docker images for each service and frontend, push to ECR, and update the AWS CDK stack. Deployment can be automated to a dev/staging environment on each merge, and perhaps manual approval for production deploys.
	•	CDK will manage versioned deployment (maybe using ECS blue/green deployments or rolling updates for zero downtime).
	•	Use Infrastructure as Code for repeatability. Keep environment-specific config (like database connection strings, API keys) in AWS SSM Parameter Store or Secrets Manager, not hardcoded. The pipeline will ensure correct values are used (for dev, possibly different from prod).
	•	We will also incorporate a step for vulnerability scanning (Docker image scans, npm audit) in the pipeline to catch security issues early.

Testing Strategy:
	•	Unit Tests: Use Jest for testing logic in isolation (e.g., functions that calculate permissions, or generate a contract PDF given data). Aim for broad coverage on pure functions and critical business rules.
	•	Integration Tests: Spin up a test database (perhaps using SQLite or a disposable Postgres via Docker) and test service layers together (e.g., create a deal and then list deals, ensuring only proper ones are returned to a user of certain role). Also test the API endpoints via an in-memory server or supertest, to ensure the routing and middleware (auth, RBAC) works.
	•	End-to-End Tests: Use a tool like Cypress or Playwright to simulate a user journey in a deployed staging environment. E.g., register investor, login, view a deal, make an offer, etc., verifying the end-to-end flow. These catch integration issues between frontend and backend.
	•	Performance Tests: Before large releases, use JMeter or Artillery to simulate load (especially on critical endpoints like GET /deals and the offer submission flow). Ensure system can handle expected concurrent users and identify bottlenecks.
	•	We will include tests for multi-tenancy: specifically verify that data from one tenant is never accessible when logged in as another tenant user (attempt cross-org IDs, etc.).

Code Quality & Standards: ESLint enforces coding standards (likely extending AirBnB or similar config for JavaScript/TypeScript). Prettier for consistent formatting. We treat any lint errors as CI failure. TypeScript strict mode on – no implicit any, etc., to catch potential bugs.

Branching and Release: Possibly use gitflow or trunk-based depending on team. Tag releases (v1.0, v1.1, etc.). The phased roadmap aligns with versions (e.g., phases 1-18 culminating in MVP release v1.0, then subsequent phases as minor version updates). We may use feature flags to merge incomplete features without exposing them until ready (to avoid long-lived branches and integration issues).

6. Monitoring, Alerting, and Telemetry

Once deployed, maintaining reliability is crucial:
	•	Logging: All services will produce structured logs (JSON format) including context like request ID, user ID (if applicable), tenant ID, and timestamp. Use a correlation ID that travels from the gateway through services (e.g., via a header or message attribute) so we can trace a single transaction across microservices. Logs will be shipped to a central system (CloudWatch Logs, or Elastic/Kibana, or a service like Datadog). We’ll set log retention policies and ensure sensitive data is not logged.
	•	Monitoring: Use CloudWatch or Prometheus/Grafana to track metrics: CPU/mem of containers, response latency of endpoints, error rates, queue lengths. Set up custom metrics for important domain events too (e.g., number of deals published per hour). Possibly use AWS X-Ray or OpenTelemetry to instrument and trace requests.
	•	Alerting: Configure alarms for: high error rate (e.g., >5% of requests failing), service down (no heartbeat), high latency (p95 > some threshold), or resource saturation (CPU > 80% for sustained period). Alerts will go to on-call devs (email/SMS/Slack).
	•	Telemetry & User Analytics: On front-end, integrate something like Google Analytics or a privacy-compliant alternative for understanding user behavior in the app (page views, drop-off in funnel, etc.). On the backend, continue capturing events that feed into how the system is used (for product analytics).
	•	Health Checks: Each service will have a health check endpoint (for ECS to check container health). Also a deeper health check that verifies connectivity to its DB or dependent service, possibly used in diagnostics.
	•	Failover and DR: We will deploy multi-AZ for database, have backups configured. Use auto-scaling for stateless services. Plan for disaster recovery by regularly backing up the database (snapshot or PITR) and storing in durable storage. The CDK setup can be replicated in another region if needed for DR (with some manual steps to restore data).

7. Security Considerations

Security is woven throughout design (as mentioned in compliance too), but to summarize technical aspects:
	•	Authentication Security: Passwords stored with strong hashing (bcrypt). Implement MFA option for user login (especially for admins) in later phase. Protect JWTs (HttpOnly cookies if web, or secure storage if mobile). Use short token lifetimes and refresh tokens if needed.
	•	Authorization Enforcement: As detailed, multi-layer (middleware + DB RLS). Also ensure that the front-end doesn’t expose options the user shouldn’t see (e.g., hide admin menu if not admin), though backend must be the final enforcement.
	•	Input Validation: All API inputs validated with Zod schemas or similar, to prevent malicious data. Sanitize outputs as well (although mostly returning stored data).
	•	OWASP Practices: Protect against injection (ORM helps, but be cautious with raw queries), XSS (React escapes content by default, but watch any HTML content), CSRF (if using cookies, implement CSRF tokens).
	•	Secrets Management: API keys for third-party (CRM, payment, etc.) are never hardcoded. In dev, we may use .env files (not committed). In prod, use AWS Secrets Manager and have services retrieve them at startup (or use env variables injected via ECS task definitions from Secrets Manager). The TRD explicitly requires “securely use secrets in production” – we fulfill that by not logging secrets and using AWS Key Management Service (KMS) integration for encryption at rest where possible.
	•	External Integrations: Each adapter will be carefully scoped. For example, if integrating with Salesforce, use the least privileges OAuth scope needed (maybe only access to leads/contacts objects). Use separate accounts/keys per tenant where possible so one tenant’s token can’t access another’s data (likely each tenant will input their own credentials for their CRM).
	•	Testing Security: Include negative tests (ensure an investor can’t call admin endpoints, etc.). Possibly run a third-party security audit or use automated scanning (like ZAP scan for the web app, Snyk for dependencies).
	•	Data Encryption: All network traffic to users goes over HTTPS (TLS). Internal service calls, if within AWS, still use encryption on the wire (service mesh or simply all endpoints TLS). Sensitive data at rest: by default RDS and S3 are encrypted. We may additionally encrypt particularly sensitive fields in the DB (like SSN if we ever store, which we likely don’t, or maybe banking info if storing for payouts – but currently not mentioned).
	•	Compliance Measures: If dealing with financial transactions (down payments), ensure PCI compliance of how we handle payment data (though by using Stripe, we outsource most of that). Also maintain audit logs for any changes in critical data (as mentioned).

8. Platform Workflow Examples (End-to-End)

(Bringing it all together with a couple of illustrative workflows leveraging the above technical components, inspired by personas):
	•	Investor Onboarding & Deal Purchase Workflow: An investor, Larry, clicks a social media link to join “Equity Homes” marketplace. This link includes an invite code or org identifier. He registers via the Auth service (triggering Identity Service to create user and Investor Profile with org=Equity Homes). He is initially flagged as “locked”. The platform sends an email to Equity Homes’ agent (via Notification Service) that a new investor is awaiting approval ￼. The agent logs into the web app (Deal Management Module) where an alert (via Analytics or Investor Service) shows a pending investor. The agent opens Larry’s profile, sees basic info and that disclosures are auto-sent. After perhaps a quick call offline, the agent clicks “Unlock”. The Investor Management Service updates Larry’s status to unlocked. Now an event “InvestorUnlocked” fires; the Notification Service emails Larry a welcome and the front-end allows him full access. Larry logs in, browses deals from Deal Service via the Marketplace Module. The Search Service (ElasticSearch) surfaces deals matching his saved criteria (initially defaults). He filters for a specific area. He sees a deal he likes and clicks “I’m Interested”. The Messaging Service logs that interest and notifies the agent in-app. Larry also decides to place an offer at asking price. The Offer Service creates the offer record and emits an event. The agent gets a notification (could be real-time via websockets or just sees in their offers list). The agent accepts the offer in the UI, which triggers Offer Service to mark it accepted and emit “OfferAccepted”. Payment Service picks that up, creates a payment intent via Stripe. Larry gets redirected to a payment page (hosted by Stripe or in-app form) and pays the $5,000 earnest money. Stripe confirms payment (webhook to Payment Service), which then emits “PaymentReceived”. The Deal Service moves the deal status to Under Contract. Immediately, the Contract Service generates the contract PDF with all details. Notification Service sends out an email to Larry and agent with the contract (or a link to e-sign). Larry and the agent both e-sign via the integrated signing link (DocuSign callback triggers Contract Service to mark signed). Title Integration sees the Under Contract event; Integration Hub creates an order with Spartan Title’s API including property address and parties ￼. Over the next week, the Title partner updates status via a portal or API (Integration Hub updates our Deal’s status fields like titleStatus). Once everything is clear, the deal is marked Closed in the system. Larry gets a notification of closing with a “Next Steps” link. That link takes him to the Services Module where he activates the Home Depot discount (Integration Hub uses Home Depot’s API to generate a coupon code). The system also awards Larry 500 loyalty points for his first purchase, and the agent gets some credit for activating a service ￼ ￼. In the backend, Analytics Service logs each step of this journey. The wholesaler org’s dashboard updates to show a new closed deal and associated metrics. This entire workflow spans multiple services but the event-driven architecture and integrated APIs ensure a smooth automation where possible.
	•	Deal Sharing & Multi-Tenant Scenario: Wholesaler A has a deal that didn’t sell in 48 hours. Their admin toggles “Share to Network”. Deal Service marks it shareable and adds entries so that Wholesaler B and C (perhaps pre-approved partners) can see it. Investors at Wholesaler B get a notification of a “Network deal” via Notification Service. One of them places an offer. The offer goes to Wholesaler A’s system (Offer Service ties it to the deal and notes which tenant investor came from). Wholesaler A’s agent sees the offer and accepts. The process continues, with Wholesaler B’s investor paying deposit and signing. The platform ensures that investor’s own agent at B might get a referral notification or maybe Wholesaler B gets a fee credit automatically (depending on business rules). The multi-tenant data handling here is tricky: the investor is actually from tenant B, making an offer on a deal of tenant A. Our design of offer likely keeps single owner (tenant A) for the deal and all related records, but references the investor who has a UserOrg at B. This means cross-tenant reference but allowed in a controlled way (the system will allow linking an investor from B to an offer on A’s deal because of the share context). Throughout, ABAC rules are carefully flexed: tenant A’s agent can see the offer and limited info about the investor (just what’s necessary, maybe the name and that they are represented by B), tenant B’s agent might see that their investor made that offer and its status, but not the full deal info if not allowed. These fine details are defined in the sharing design. After closing, Analytics might record that as a network transaction for both tenants. This scenario validates that our architecture can handle complex multi-org interactions without breaking isolation except where intended.

In conclusion, the technical architecture and requirements specified will deliver a powerful, flexible platform that addresses the product needs. By adhering to robust standards (like JSON-C for APIs ￼), enforcing multi-tenancy from the ground-up, and planning for incremental feature releases, we ensure the system is maintainable and scalable. Both the PRD and TRD together provide a comprehensive blueprint for building the Unified Real Estate Investment Platform with a clear path from foundational development to advanced, innovative features.

Sources:
	•	New Marketplace Platform Initiative – internal strategy document outlining multi-tenant approach and roadmap ￼ ￼.
	•	“2028 Experience” Personas – future-state user scenarios illustrating desired features like seamless onboarding, integrated financing, and loyalty perks ￼ ￼.
	•	API Standards v1 – guidelines on JSON API structuring (JSON-C) to ensure consistent request/response design ￼ ￼.
	•	Internal Architecture Notes – requirements for RBAC/ABAC enforcement and data isolation in a multi-tenant system ￼.
