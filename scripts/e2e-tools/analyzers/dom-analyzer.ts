/**
 * DOM Snapshot Analyzer for E2E Tests
 *
 * Parses error-context.md files generated by Playwright tests
 * to extract meaningful information about the UI state at failure.
 */

import { readFileSync, existsSync, readdirSync, statSync } from 'fs';
import { join } from 'path';

/**
 * A UI element parsed from a DOM snapshot
 */
export interface UIElement {
  type: string;
  attributes: Record<string, string>;
  text?: string;
  children: UIElement[];
}

/**
 * Complete DOM snapshot
 */
export interface DOMSnapshot {
  elements: UIElement[];
  raw: string;
}

/**
 * Result of analyzing a DOM snapshot
 */
export interface DOMAnalysisResult {
  file: string;
  testName: string;
  browser: string;
  snapshot: DOMSnapshot;
  issues: string[];
  hasErrorState: boolean;
  hasLoadingState: boolean;
  visibleText: string;
}

/**
 * Common error indicators in UI
 */
const ERROR_INDICATORS = [
  'error',
  'failed',
  'crash',
  'something went wrong',
  'unexpected error',
  'system error',
  'network error',
  'server error',
  '500',
  'internal server error',
];

/**
 * Loading indicators in UI
 */
const LOADING_INDICATORS = [
  'loading',
  'spinner',
  'please wait',
  'fetching',
];

/**
 * DOM Analyzer Class
 *
 * Analyzes Playwright error context files to understand
 * the UI state when a test failed.
 */
export class DOMAnalyzer {
  private readonly testResultsDir: string;

  constructor(testResultsDir: string = 'test-results') {
    this.testResultsDir = testResultsDir;
  }

  /**
   * Find and analyze all error-context.md files
   */
  analyzeAllSnapshots(): DOMAnalysisResult[] {
    const results: DOMAnalysisResult[] = [];
    const baseDir = join(process.cwd(), this.testResultsDir);

    if (!existsSync(baseDir)) {
      return results;
    }

    this.walkDirectory(baseDir, (file) => {
      if (file.endsWith('error-context.md')) {
        const result = this.analyzeSnapshot(file);
        if (result) {
          results.push(result);
        }
      }
    });

    return results;
  }

  /**
   * Analyze a single error-context.md file
   */
  analyzeSnapshot(filePath: string): DOMAnalysisResult | null {
    try {
      const content = readFileSync(filePath, 'utf-8');
      const snapshot = this.parseSnapshot(content);

      // Extract test info from path
      const testInfo = this.extractTestInfo(filePath);

      // Analyze for known issues
      const issues = this.detectIssues(snapshot);

      return {
        file: filePath,
        testName: testInfo.testName,
        browser: testInfo.browser,
        snapshot,
        issues,
        hasErrorState: this.hasErrorState(snapshot),
        hasLoadingState: this.hasLoadingState(snapshot),
        visibleText: this.extractVisibleText(snapshot),
      };
    } catch {
      return null;
    }
  }

  /**
   * Parse YAML-like snapshot format from Playwright
   */
  private parseSnapshot(content: string): DOMSnapshot {
    const elements: UIElement[] = [];
    const lines = content.split('\n');

    let inYaml = false;
    let currentIndent = 0;
    const stack: UIElement[] = [];

    for (const line of lines) {
      if (line.includes('```yaml')) {
        inYaml = true;
        continue;
      }
      if (line.includes('```') && inYaml) {
        inYaml = false;
        continue;
      }
      if (!inYaml) continue;

      // Parse YAML-like structure
      const match = line.match(/^(\s*)- (\w+)(?:\s+\[([^\]]+)\])?(?:\s*:\s*(.+))?/);
      if (match) {
        const [, indent, type, attributes, text] = match;
        const indentLevel = indent?.length || 0;

        const element: UIElement = {
          type,
          attributes: this.parseAttributes(attributes || ''),
          text: text?.trim(),
          children: [],
        };

        // Handle nesting
        while (stack.length > 0 && currentIndent >= indentLevel) {
          stack.pop();
          currentIndent -= 2;
        }

        if (stack.length > 0) {
          stack[stack.length - 1].children.push(element);
        } else {
          elements.push(element);
        }

        stack.push(element);
        currentIndent = indentLevel;
      }
    }

    return { elements, raw: content };
  }

  /**
   * Parse attributes like [ref=e2] [level=2]
   */
  private parseAttributes(attrString: string): Record<string, string> {
    const attrs: Record<string, string> = {};
    const regex = /(\w+)=([^\s\]]+)/g;
    let match: RegExpExecArray | null;

    while ((match = regex.exec(attrString)) !== null) {
      attrs[match[1]] = match[2];
    }

    return attrs;
  }

  /**
   * Extract test info from file path
   */
  private extractTestInfo(filePath: string): { testName: string; browser: string } {
    const parts = filePath.split('/');
    const dirName = parts[parts.length - 2] || '';

    // Format: specs-{path}-{testname}-{browser}
    const match = dirName.match(/specs-(.+)-([^-]+)$/);

    if (match) {
      return {
        testName: match[1].replace(/-/g, ' '),
        browser: match[2],
      };
    }

    // Try alternative format
    const altMatch = dirName.match(/([^-]+)-chromium|firefox|webkit$/);
    if (altMatch) {
      return {
        testName: altMatch[1].replace(/-/g, ' '),
        browser: dirName.split('-').pop() || 'unknown',
      };
    }

    return {
      testName: dirName || 'unknown',
      browser: 'unknown',
    };
  }

  /**
   * Detect known issues from DOM snapshot
   */
  private detectIssues(snapshot: DOMSnapshot): string[] {
    const issues: string[] = [];
    const text = this.extractVisibleText(snapshot).toLowerCase();

    // Check for error states
    if (this.hasErrorState(snapshot)) {
      issues.push('Error boundary triggered - check console for details');
    }

    // Check for loading spinners
    if (this.hasLoadingState(snapshot)) {
      issues.push('Page may not have finished loading');
    }

    // Check for empty content
    if (snapshot.elements.length === 0) {
      issues.push('DOM snapshot is empty - page may have crashed');
    }

    // Check for specific error messages
    if (text.includes('system error')) {
      issues.push('System error detected - likely unhandled exception');
    }
    if (text.includes('network error')) {
      issues.push('Network error - check backend connectivity');
    }
    if (text.includes('not found') || text.includes('404')) {
      issues.push('404 or missing resource error');
    }
    if (text.includes('500') || text.includes('internal server error')) {
      issues.push('500 Internal Server Error - check backend logs');
    }
    if (text.includes('timeout')) {
      issues.push('Timeout error detected');
    }
    if (text.includes('unauthorized') || text.includes('401')) {
      issues.push('Authentication error - check login state');
    }
    if (text.includes('forbidden') || text.includes('403')) {
      issues.push('Permission denied - check user permissions');
    }

    return issues;
  }

  /**
   * Check if snapshot shows an error state
   */
  private hasErrorState(snapshot: DOMSnapshot): boolean {
    const text = this.extractVisibleText(snapshot).toLowerCase();

    for (const indicator of ERROR_INDICATORS) {
      if (text.includes(indicator)) {
        return true;
      }
    }

    // Check for error-related attributes
    if (
      snapshot.raw.includes('role="alert"') ||
      snapshot.raw.includes('aria-invalid="true"') ||
      snapshot.raw.includes('data-error')
    ) {
      return true;
    }

    return false;
  }

  /**
   * Check if snapshot shows a loading state
   */
  private hasLoadingState(snapshot: DOMSnapshot): boolean {
    const text = this.extractVisibleText(snapshot).toLowerCase();

    for (const indicator of LOADING_INDICATORS) {
      if (text.includes(indicator)) {
        return true;
      }
    }

    // Check for loading-related attributes
    if (
      snapshot.raw.includes('aria-busy="true"') ||
      snapshot.raw.includes('data-loading') ||
      snapshot.raw.includes('data-pending')
    ) {
      return true;
    }

    return false;
  }

  /**
   * Extract all visible text from snapshot
   */
  private extractVisibleText(snapshot: DOMSnapshot): string {
    const texts: string[] = [];

    const extractFromElement = (el: UIElement): void => {
      if (el.text) {
        texts.push(el.text);
      }
      for (const child of el.children) {
        extractFromElement(child);
      }
    };

    for (const el of snapshot.elements) {
      extractFromElement(el);
    }

    // Also extract from raw content (for text not in YAML)
    const textMatches = snapshot.raw.match(/"text":\s*"([^"]+)"/g);
    if (textMatches) {
      for (const match of textMatches) {
        const textValue = match.match(/"text":\s*"([^"]+)"/);
        if (textValue) {
          texts.push(textValue[1]);
        }
      }
    }

    return texts.join(' ');
  }

  /**
   * Walk directory recursively
   */
  private walkDirectory(dir: string, callback: (file: string) => void): void {
    try {
      const entries = readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = join(dir, entry.name);
        if (entry.isDirectory()) {
          this.walkDirectory(fullPath, callback);
        } else if (entry.isFile()) {
          callback(fullPath);
        }
      }
    } catch {
      // Ignore errors
    }
  }

  /**
   * Find snapshots with specific issues
   */
  findWithIssues(issuePattern: RegExp): DOMAnalysisResult[] {
    const all = this.analyzeAllSnapshots();
    return all.filter((r) =>
      r.issues.some((issue) => issuePattern.test(issue))
    );
  }

  /**
   * Get compact summary of all snapshots
   */
  getCompactSummary(): string {
    const results = this.analyzeAllSnapshots();

    if (results.length === 0) {
      return 'DOM:NONE';
    }

    const errors = results.filter((r) => r.hasErrorState).length;
    const loading = results.filter((r) => r.hasLoadingState).length;

    return `DOM:${results.length}|ERR:${errors}|LOAD:${loading}`;
  }
}

// Lazy singleton instance
let _domAnalyzer: DOMAnalyzer | null = null;

/**
 * Get the singleton DOMAnalyzer instance
 */
export function getDOMAnalyzer(): DOMAnalyzer {
  if (!_domAnalyzer) {
    _domAnalyzer = new DOMAnalyzer();
  }
  return _domAnalyzer;
}

/**
 * Analyze all DOM snapshots (convenience function)
 */
export function analyzeAllSnapshots(): DOMAnalysisResult[] {
  return getDOMAnalyzer().analyzeAllSnapshots();
}

/**
 * Analyze a single snapshot (convenience function)
 */
export function analyzeSnapshot(filePath: string): DOMAnalysisResult | null {
  return getDOMAnalyzer().analyzeSnapshot(filePath);
}
